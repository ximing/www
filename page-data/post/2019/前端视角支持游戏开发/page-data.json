{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/post/2019/前端视角支持游戏开发/","result":{"data":{"site":{"siteMetadata":{"title":"一席之地","author":"xi ming"}},"markdownRemark":{"id":"278ab392-bf95-57cd-abf1-ee8e352c21bc","excerpt":"最近实现了一个天天领钱 H5 游戏，一期基础场景如下\nimage.png 在做果园之前，我们和其他部门专职做游戏的同学充分的进行了沟通，得到很多宝贵的经验：\n框架层面：了解到他们使用的是 cocos creator 框架，但是提到 cocos 框架是 c++迁移到 js…","html":"<p>最近实现了一个天天领钱 H5 游戏，一期基础场景如下\n<img src=\"https://asset-cdn.oss-cn-beijing.aliyuncs.com/imgs/20230606125942.png\" alt=\"image.png\"></p>\n<p>在做果园之前，我们和其他部门专职做游戏的同学充分的进行了沟通，得到很多宝贵的经验：\n框架层面：了解到他们使用的是 cocos creator 框架，但是提到 cocos 框架是 c++迁移到 js 的，所以本身就有诸多小问题，所以新的游戏他们都使用的是 laya 框架，也推荐我们来使用。\n通讯层面：后端交互使用的是 websocket 实现的，通讯相关的复杂度很高，因为后端是有状态服务，前端要做 request event 和 response event 之间的关联。所以建议我们还是用短连接。</p>\n<p>回来后深入学习了下 laya 框架，也玩了一些同类的游戏，发现其实这类游戏与其说是游戏还不如说是一个运营活动。其实技术上游戏元素很少，只是玩法上是类似游戏的交互。所以未必真的需要上 laya 框架另外：</p>\n<ul>\n<li>团队技术储备都是偏向小程序/H5 游戏类的都没什么经验，产品侧给的时间比较短风险也大</li>\n<li>游戏本身很简单(交互性很低)，判断不需要太复杂的游戏框架</li>\n</ul>\n<h2 id=\"架构分析\" style=\"position:relative;\">架构分析<a href=\"#%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90\" aria-label=\"架构分析 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h2>\n<p>那么基于这样的一个限制，思考了一个新的做法：</p>\n<ol>\n<li>美术同学做好果园需要的骨骼动画，</li>\n<li>前端通过某种方式当用户点击的时候播放对应动画即可</li>\n</ol>\n<p>剩下所有功能都使用前端技术(React)去做。</p>\n<p>关于骨骼动画目前其实三部分：</p>\n<ol>\n<li>树的点击，成长，升级；</li>\n<li>水壶的浇水；</li>\n<li>奖励的弹窗</li>\n<li>领水滴动画</li>\n</ol>\n<p>所以其实就是四个动画文件，在合适的时机去播放合适的动画就行了。调研了一圈，最后选择使用 pixi.js V5 来做这游戏的画布，封装了 pixi-dragonbones 进行龙骨的播放。</p>\n<p>所以我们的整个架构就变成了下面这样三层的结构，底层就是主场景的绘制，主要动画的执行，中间层就是各种业务弹层，上层是动画弹层\n<img src=\"https://asset-cdn.oss-cn-beijing.aliyuncs.com/imgs/20230606130257.png\" alt=\"image.png\"></p>\n<h2 id=\"游戏引擎篇\" style=\"position:relative;\">游戏引擎篇<a href=\"#%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E7%AF%87\" aria-label=\"游戏引擎篇 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h2>\n<p>最开始的时候，只是单纯的封装了三层架构到一个 Game 类里面，然后游戏精灵的创建还是使用的类似 JQuery 的方式进行的。所以一旦有数据层面的变动，必须直接找到对应的精灵实例进行操作，比如坐标变化。这样其实有一些倒退。写的过程中也很不爽，后面就思考了下响应式的做法，有两个办法</p>\n<ol>\n<li>基于 RXJS+对象</li>\n<li>类似 react 的方式声明对象，数据变化导致精灵属性的变化由框架维护</li>\n</ol>\n<p>因为之前写过一些 RXJS 的项目，了解里面的复杂度，再团队内推很可能导致较大的延期风险，毕竟很多 RXJS 配套的运行时都没有研发。所以潜意识里就第一时间放弃这个做法（也是目前最后悔的地方，应该用的，后面再聊），而为了方便现有开发，将已有的 react 资产集成进来开始考虑如何用 react 的方式进行游戏开发，第一反应就是实现一个 ReactPiXi (对标 ReactDom)，所以快速写了一个 ReactPiXi 验证了一下发现果然可行。\n继续完善的过程中，查资料偶然发现一个开源的方案 @inlet/react-pixi ，大部分都实现了，但是遇到点小问题，提了 pr 也很快合入了，最后就选定了这个库，至此游戏精灵对象和 dom 对象两层就在逻辑上合并为一层了。\n<img src=\"https://asset-cdn.oss-cn-beijing.aliyuncs.com/imgs/image.png\" alt=\"image.png\">\n游戏精灵的 react 写法\n这样游戏对象和数据流就可以通过声明的方式进行关联了。<strong>至此整体开发就完全变成前端最熟悉的开发模式，和游戏就没有太多关系了</strong>。后续这方面的工作就和 RN 一样，要使用 react 组件的方式封装一些原生的精灵对象即可。</p>\n<h2 id=\"数据流篇\" style=\"position:relative;\">数据流篇<a href=\"#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AF%87\" aria-label=\"数据流篇 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h2>\n<p>数据流选用了 mobx，这是目前复盘看比较失败的地方。mobx 的优势最大的就是响应式编程，当时使用 mobx 是想的当数据变化的时候，直接响应的回调操作游戏精灵，类似下面的代码</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">autorun(()=>{\n  const sprite = new Sprite();\n  sprite.y = store.tree.x;\n  sprite.x = store.tree.y;\n})</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>这样只有在tree的x或者y属性变化的时候才会执行这个回调，能有效的进行数据和对象的绑定，但是后面换成react架构之后，绑定关系在render函数中就实现了，所以根本不需要这么写。当时考虑到mobx和react也能很好的集成，所以我们就没有进行数据源的更换，还是沿用了mobx。</p>\n<p>在正常业务开发的时候mobx没有太多的问题，但是当进行多个动画对象联动的时候mobx就出现了比较大的麻烦。比如浇水动画播放到2s的时候播放进度条动画，等服务端返回的时候播放数升级动画同时更新主场景，然后升级2s的时候出弹层动画。整个流程使用mobx就比较难以描述，还是要在业务层代码写很多离散的逻辑。而这些正好是rxjs比较擅长解决的问题，会把同步的异步的推拉两种架构都汇总到同一个流的模式上完成，其实是最契合目前的场景的。</p>\n<p>另外发现一个问题，mobx 的开发者工具没有 redux 的好用，仅仅支持简单的数据流变化，这种变化监听是牺牲了易用性完成的，及必须将每个 state 的操作都通过 action 进行才可以。而这么写在开发角度看就回退到了 redux 的模式。另外 mobx 对数据没有一个很好的管理方案，store 是离散的，所以没办法对 store 做很好的镜像上报，不容易排查问题。</p>\n<p>目前实践下来 Mobx 目前比较好的点就是不需要关注更新位置，只有变更的组件才会更新，不需要写 memo 之类的函数进行处理。</p>\n<h2 id=\"资源管理篇\" style=\"position:relative;\">资源管理篇<a href=\"#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%AF%87\" aria-label=\"资源管理篇 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h2>\n<p>资源管理的诉求</p>\n<ol>\n<li>支持换肤，动态换肤/静态换肤</li>\n<li>支持自动图集(雪碧图)</li>\n<li>支持自动有损压缩</li>\n<li>支持webp</li>\n<li>最好能做到设计自行传图片，应用后线上自动生效，不需要研发介入</li>\n</ol>\n<p>针对上面的诉求资源管理最开始希望做一个托管的网站进行管理，解耦设计和研发之间的依赖。但是发现流程和版本控制上比较复杂，几经讨论就暂时搁置了这个方案，需要进一步探索</p>\n<p>新的方案暂时不满足第五点，满足前四点就只需要提供一个本地的构建工具即可，我们按照目录进行了约定，将游戏内使用的资源分为三类：</p>\n<ol>\n<li>文案资源</li>\n<li>颜色资源</li>\n<li>静态文件资源(json动画文件，图片文件等)</li>\n</ol>\n<p>目录结构：\n<img src=\"https://asset-cdn.oss-cn-beijing.aliyuncs.com/imgs/20230606131123.png\" alt=\"image.png\"></p>\n<p>所有主题默认继承base，如果存在同名的就覆盖base里面的配置，其中比较特殊的是files下有sprites目录，这个目录下面每个文件夹都会被自动打包成一张图片，最后处理完所有资源后会生成d.ts和json两个文件。项目中实现了一个资源替换的模块统一处理了游戏内皮肤替换和H5皮肤替换</p>\n<p>至此，一个使用 react 开发前端营销游戏的架子就完整的搭建起来了。基本满足我们的诉求</p>\n<ol>\n<li>团队成员没有游戏开发经验如何快速上手开发游戏</li>\n<li>已有前端资产如何和游戏打通</li>\n<li>能支撑业务长期迭代</li>\n</ol>\n<h3 id=\"文档\" style=\"position:relative;\">文档<a href=\"#%E6%96%87%E6%A1%A3\" aria-label=\"文档 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h3>\n<p><a href=\"https://juejin.im/post/5c563a4ef265da2ddb293ba3#heading-2\">https://juejin.im/post/5c563a4ef265da2ddb293ba3#heading-2</a>\n<a href=\"https://github.com/Zainking/LearningPixi#takingitfurther\">https://github.com/Zainking/LearningPixi#takingitfurther</a>\n<a href=\"https://reactpixi.org/components/container#props\">https://reactpixi.org/components/container#props</a></p>","fields":{"slug":"/post/2019/前端视角支持游戏开发/"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90\">架构分析</a></p>\n</li>\n<li>\n<p><a href=\"#%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E7%AF%87\">游戏引擎篇</a></p>\n</li>\n<li>\n<p><a href=\"#%E6%95%B0%E6%8D%AE%E6%B5%81%E7%AF%87\">数据流篇</a></p>\n</li>\n<li>\n<p><a href=\"#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E7%AF%87\">资源管理篇</a></p>\n<ul>\n<li><a href=\"#%E6%96%87%E6%A1%A3\">文档</a></li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"前端视角支持游戏开发","date":"2019年11月12日","description":null,"tags":["游戏","react"]},"wordCount":{"words":278,"paragraphs":45,"sentences":45}}},"pageContext":{"slug":"/post/2019/前端视角支持游戏开发/","previous":{"fields":{"slug":"/post/2019/typescript/"},"frontmatter":{"title":"typescript高级用法梳理","tags":null,"description":null}},"next":{"fields":{"slug":"/post/2019/react-mini-program/"},"frontmatter":{"title":"使用 完整react能力 开发小程序","tags":["小程序","react"],"description":null}}}},"staticQueryHashes":["2887002447","3110208747","3255319198","63159454"],"slicesMap":{}}