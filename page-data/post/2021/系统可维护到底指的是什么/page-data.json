{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/post/2021/系统可维护到底指的是什么/","result":{"data":{"site":{"siteMetadata":{"title":"一席之地","author":"xi ming"}},"markdownRemark":{"id":"8dff865d-be2b-5699-8b81-5c8e7dfe702f","excerpt":"在美团一些大型业务开发中，经常会出现大家觉得系统维护不下去了，一个反复被提及的词就是代码复杂度高。但是后台业务确很少有类似的声音，其实后台业务的复杂度也不低，但是为什么会有类似的情况发生呢，其实我认为对是否可维护不完全是客观的，比如考虑以下几个 case…","html":"<p>在美团一些大型业务开发中，经常会出现大家觉得系统维护不下去了，一个反复被提及的词就是代码复杂度高。但是后台业务确很少有类似的声音，其实后台业务的复杂度也不低，但是为什么会有类似的情况发生呢，其实我认为对是否可维护不完全是客观的，比如考虑以下几个 case</p>\n<ol>\n<li>有人接手前人的项目后，会觉得可维护性差，然后进行重构工作，但是在上一任维护人上并没有类似的想法</li>\n<li>很多人会说 react 项目太复杂，不好开发维护，但是 react core team 的人没觉得不好维护</li>\n<li>架构师走了之后，团队成员换了一批会觉得之前的东西很难维护</li>\n<li>业务支持多个业态，或者业务干脆换了一个方向，各种原因下系统还是局部复用的，整个系统会让人感觉不可维护</li>\n</ol>\n<h2 id=\"可维护性和什么有关\" style=\"position:relative;\">可维护性和什么有关<a href=\"#%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3\" aria-label=\"可维护性和什么有关 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h2>\n<p>我将上面提到的情况大致的划分成了下面的表格的四个维度(链接为我对应的具体的思考)：</p>\n<table>\n<thead>\n<tr>\n<th>客观情况</th>\n<th>人相关</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>业务复杂度：《<a href=\"#\">🐣系统中复杂度体现在哪些方面</a>》《<a href=\"#\">🐣为什么复杂的业务不好做</a>》</td>\n<td>技能：拥有一定深度和广度 《<a href=\"#\">✅如何看待技术深度与广度</a>》</td>\n</tr>\n<tr>\n<td>代码与架构：《<a href=\"#\">🐣如何做好前端架构</a>》</td>\n<td>熟悉程度：(时间 +意愿)*理解力/频次</td>\n</tr>\n</tbody>\n</table>\n<p>在这四个维度中，业务复杂度是无法改变的，对项目熟悉程度也需要精力(时间+意愿)，所以回到优选项目我们说它难以维护的原因可以如下分析：</p>\n<ol>\n<li>熟悉程度低：为了赶排期，经常协调人协助开发一些本来不是他负责的业务功能，导致大家对项目平均熟悉度都偏低</li>\n<li>架构不合理：过去每周2大迭代+3迭代，同时排查很多线上问题导致大家没精力进行周全的技术设计</li>\n<li>业务复杂度：团长，用户，新人，老客，促销，活动等等聚集到一起业务case相对复杂</li>\n<li>技能：低职级的同学主力开发，KP精力更多在排查线上问题，高职级的事务性工作多，导致项目技能平均投入偏低</li>\n</ol>\n<p>整体形成了如下图红色部分的负向循环:\n<img src=\"https://asset-cdn.oss-cn-beijing.aliyuncs.com/imgs/20230605124411.png\" alt=\"image.png\"></p>\n<h2 id=\"如何提高可维护性\" style=\"position:relative;\">如何提高可维护性<a href=\"#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7\" aria-label=\"如何提高可维护性 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h2>\n<h3 id=\"1-业务复杂度\" style=\"position:relative;\">(1) 业务复杂度<a href=\"#1-%E4%B8%9A%E5%8A%A1%E5%A4%8D%E6%9D%82%E5%BA%A6\" aria-label=\"1 业务复杂度 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h3>\n<p>业务变复杂是技术没办法解决的，是客观的商业行为导致的。业务本身越复杂，所包含的信息量就会越大，复杂度就会很高，而系统架构设计是无法消除业务整体复杂度的，它只能让复杂度可以被拆分，让团队不同的人可以面对一个被切分后的相对可控的业务难度，但架构师(系统主R)还需要将所有被切分的信息聚合起来，这些工程方法客观上降低了人类理解复杂度，但实际增加了系统实体复杂度。不过降低理解复杂度可以客观提高系统可维护性，所以我们还是要对业务有一个很好的认识从而进行对应的代码与架构的设计。</p>\n<h3 id=\"2-代码与架构\" style=\"position:relative;\">(2) 代码与架构<a href=\"#2-%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%9E%B6%E6%9E%84\" aria-label=\"2 代码与架构 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h3>\n<h4 id=\"21-如何做好架构\" style=\"position:relative;\">2.1. 如何做好架构<a href=\"#21-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E6%9E%B6%E6%9E%84\" aria-label=\"21 如何做好架构 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h4>\n<p>首先要明确的一点是不要在开发过程中教条的应用一些设计模式和架构模型，所有的架构都是为了合理的将业务抽象成对应的技术实现，抽象好的表现是适应度函数的曲线比较贴合业务真实复杂度，抽象的不好，一个简单的页面也会让人难以理解。《<a href=\"#\">🐣如何做好前端架构</a>》</p>\n<p>架构另一个作用主要在业务拆分，我们需要通过确定模块开发所需了解的最小知识给实际业务开发同学做减法，不需要理解的模块就不要轻易展示出来，最大程度减少开发者的心智负担。\n<img src=\"https://asset-cdn.oss-cn-beijing.aliyuncs.com/imgs/20230605124436.png\" alt=\"image.png\"></p>\n<p>前端项目中一般分层做的相对较好，比如常规做法我们会把一个业务中的前端项目分为 容器层，基础能力层(网络，日志，安全)，物料层，业务能力层(登录，支付，购物车)等等，但是具体到每个业务模块对业务的抽象可能做的还不够，目前集中讨论的都是数据流和框架(React/Vue)，但是这些只是手段，并不能帮我们很好的抽象业务逻辑。服务端在这些事情上有很多的抽象比如六边形架构，DDD 等等，前端需要在这件事情上有更深入的探索。</p>\n<p>另外一个合理的架构还需要包含文档，测试等帮助人理解业务&#x26;代码的配套设施。</p>\n<h4 id=\"22如何衡量代码是否可维护\" style=\"position:relative;\">2.2.如何衡量代码是否可维护<a href=\"#22%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%B4%E6%8A%A4\" aria-label=\"22如何衡量代码是否可维护 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h4>\n<p>因为前端再过去的复杂度一直不是很高，通过框架可以很好的解决维护的问题，所以前端在这件事情上面关注的还是比较少。直到最近几年出现很多巨石应用，才在一些业务团队中被反复提及，但是目前主要衡量的可维护的方法是通过质量指标和主观感受来进行衡量，这很显然没太多的说服力。我们实际期望的获得一个适应度函数(Fitness Function)Fi，公式为：Maintainable = Fi(Feature) ，其中业务功能变化的时候我们得到的可维护性也尽可能的贴合，这里尽可能的贴合是指我在《<a href=\"https://km.sankuai.com/page/1209515178\">🐣系统中复杂度体现在哪些方面</a>》中提到三点：</p>\n<blockquote>\n<ol>\n<li>不要修改放大 (Change Amplification)</li>\n<li>减轻认知负担 (Cognitive Load)</li>\n<li>减少未知的未知 (Unknown Unknown)</li>\n</ol>\n</blockquote>\n<p>如何衡量是否贴合比较难的地方在于Feature的变化是多种多样的，业务的逻辑就是没有逻辑，我们没办法正面求得Fi，只能通过一些侧面的指标来衡量。业界上有很多理论(见备注)，从两个方面的指标来说明：</p>\n<h5 id=\"源码方面\" style=\"position:relative;\">源码方面<a href=\"#%E6%BA%90%E7%A0%81%E6%96%B9%E9%9D%A2\" aria-label=\"源码方面 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h5>\n<p>指标：LLOC\n相比于传统的 LOC，明显LLOC更稳定</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">// LOC 1 \n// LLOC2 \nif(true) console.log('hello'); \n// LOC 3或4 \n// LLOC 2 \nif(true) {\n  console.log('hello');\n}</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pre></div>\n<p>指标：Halstead Complexity(HV)\n<a href=\"https://github.com/aametwally/Halstead-Complexity-Measures\">GitHub - aametwally/Halstead-Complexity-Measures: Calculate Halstead complexity software measures using ASTParser. These metrics are computed statically, without program execution.</a></p>\n<p>指标：Cognitive Complexity (CC)\n<a href=\"https://www.sonarsource.com/docs/CognitiveComplexity.pdf\">认知复杂度</a> 下面的两种方法有着相同的圈复杂度，但是在可理解性方面有着显著的不同\n<img src=\"https://asset-cdn.oss-cn-beijing.aliyuncs.com/imgs/20230605124728.png\" alt=\"image.png\">\n圈复杂度的数学模型赋予了这两种方法同等的权重，但是直观上很明显 sumOfPrimes 的控制流比 getWords 更难理解。这就是为什么认知复杂性放弃了使用数学模型来评估控制流，转而使用一套简单的规则来将程序员的直觉转化为数字。\n我们代码中的一个 bad case 用认知复杂度可以很好地衡量出来如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-text line-numbers\"><code class=\"language-text\">a &amp;&amp; b //圈复杂度：2 ，认知复杂度：2 \na &amp;&amp; b &amp;&amp; c &amp;&amp; d // 圈复杂度：4 ，认知复杂度：2 \na || b &amp;&amp; c || d // 圈复杂度：4 ，认知复杂度：4</code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span></span></pre></div>\n<h5 id=\"架构方面\" style=\"position:relative;\">架构方面<a href=\"#%E6%9E%B6%E6%9E%84%E6%96%B9%E9%9D%A2\" aria-label=\"架构方面 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h5>\n<p>内聚性 共生性(耦合) 后续会写一篇文章单独展开讲</p>\n<h5 id=\"指标函数\" style=\"position:relative;\">指标函数<a href=\"#%E6%8C%87%E6%A0%87%E5%87%BD%E6%95%B0\" aria-label=\"指标函数 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h5>\n<p>Maintainability Index：由 Paul Oman and Jack Hagemeister 在1992年提出，它是若干种度量的混合，包括 HV, CC 以及 LLOC 三个不同指标，原始公式为：<code class=\"language-text\">MI=171−5.2lnV−0.23G−16.2lnL</code> SEI 的衍生版本 <code class=\"language-text\">MI=171−5.2log2​ V−0.23G−16.2log2​ L+50sin(2.4C​)</code>\n还有 Visual Studio 衍生版本， Radon 衍生版本等等\n通过以上的任意一个函数都可以近似求得适应度指标，我们就可以观测业务代码在迭代过程中的指标变化，从而得到是向好还是向坏的一些衡量标准，达到卡控代码的目标</p>\n<h3 id=\"3-熟悉程度\" style=\"position:relative;\">(3) 熟悉程度<a href=\"#3-%E7%86%9F%E6%82%89%E7%A8%8B%E5%BA%A6\" aria-label=\"3 熟悉程度 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h3>\n<p>这块主要通过流程规范来解决，比如锁定主R，减低迭代频次，提高系统设计细节要求等方法提高团队对代码的平均熟悉水平</p>\n<h3 id=\"4-技能\" style=\"position:relative;\">(4) 技能<a href=\"#4-%E6%8A%80%E8%83%BD\" aria-label=\"4 技能 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h3>\n<p>这块主要就是看岗位胜任度了，选用育励汰等方法论</p>","fields":{"slug":"/post/2021/系统可维护到底指的是什么/"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7%E5%92%8C%E4%BB%80%E4%B9%88%E6%9C%89%E5%85%B3\">可维护性和什么有关</a></p>\n</li>\n<li>\n<p><a href=\"#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7\">如何提高可维护性</a></p>\n<ul>\n<li>\n<p><a href=\"#1-%E4%B8%9A%E5%8A%A1%E5%A4%8D%E6%9D%82%E5%BA%A6\">(1) 业务复杂度</a></p>\n</li>\n<li>\n<p><a href=\"#2-%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%9E%B6%E6%9E%84\">(2) 代码与架构</a></p>\n<ul>\n<li>\n<p><a href=\"#21-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E6%9E%B6%E6%9E%84\">2.1. 如何做好架构</a></p>\n</li>\n<li>\n<p><a href=\"#22%E5%A6%82%E4%BD%95%E8%A1%A1%E9%87%8F%E4%BB%A3%E7%A0%81%E6%98%AF%E5%90%A6%E5%8F%AF%E7%BB%B4%E6%8A%A4\">2.2.如何衡量代码是否可维护</a></p>\n<ul>\n<li><a href=\"#%E6%BA%90%E7%A0%81%E6%96%B9%E9%9D%A2\">源码方面</a></li>\n<li><a href=\"#%E6%9E%B6%E6%9E%84%E6%96%B9%E9%9D%A2\">架构方面</a></li>\n<li><a href=\"#%E6%8C%87%E6%A0%87%E5%87%BD%E6%95%B0\">指标函数</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#3-%E7%86%9F%E6%82%89%E7%A8%8B%E5%BA%A6\">(3) 熟悉程度</a></p>\n</li>\n<li>\n<p><a href=\"#4-%E6%8A%80%E8%83%BD\">(4) 技能</a></p>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"系统可维护到底指的是什么","date":"January 01, 2021","description":null},"wordCount":{"words":261,"paragraphs":40,"sentences":42}}},"pageContext":{"slug":"/post/2021/系统可维护到底指的是什么/","previous":{"fields":{"slug":"/post/2023/04-09-余弦相似度匹配/"},"frontmatter":{"title":"余弦相似度匹配(适用于openai的向量数据库底层实现)","tags":["算法","llm"],"description":null}},"next":{"fields":{"slug":"/post/2021/并发请求问题/"},"frontmatter":{"title":"并发请求","tags":["算法","llm"],"description":null}}}},"staticQueryHashes":["1006016363","324394502","63159454"],"slicesMap":{}}