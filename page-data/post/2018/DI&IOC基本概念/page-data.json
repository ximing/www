{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/post/2018/DI&IOC基本概念/","result":{"data":{"site":{"siteMetadata":{"title":"一席之地","author":"xi ming"}},"markdownRemark":{"id":"032b2909-f1fc-5b6b-9430-b6bae0aef8e0","excerpt":"DI 和 IOC 的关系 DI（依赖注入）和 IOC（控制反转）是两个相关但不完全相同的概念。\n控制反转（IOC）是一种设计原则，它强调将控制权从应用程序代码中转移到外部容器或框架中。根据 IOC 原则，应用程序的组件不应该负责自己的依赖关系的解析和管理，而是将这些责任交给外部的容器。通过 IOC…","html":"<h2 id=\"di-和-ioc-的关系\" style=\"position:relative;\">DI 和 IOC 的关系<a href=\"#di-%E5%92%8C-ioc-%E7%9A%84%E5%85%B3%E7%B3%BB\" aria-label=\"di 和 ioc 的关系 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h2>\n<p>DI（依赖注入）和 IOC（控制反转）是两个相关但不完全相同的概念。\n控制反转（IOC）是一种设计原则，它强调将控制权从应用程序代码中转移到外部容器或框架中。根据 IOC 原则，应用程序的组件不应该负责自己的依赖关系的解析和管理，而是将这些责任交给外部的容器。通过 IOC，应用程序的组件变得松耦合，可以更容易地被替换、重用和测试。</p>\n<p>依赖注入（DI）是实现IOC的一种具体方式。DI是一种将依赖关系注入到组件中的机制，以解耦组件与其依赖的创建和管理。通过DI，依赖关系不是由组件自身来创建和解析，而是由外部的注入器或容器来处理。这意味着组件不需要关心如何获取它所依赖的对象，而只需要声明它所需要的依赖，并让容器负责注入。</p>\n<p>因此，DI 是 IOC 的一种实现方式，通过依赖注入实现了控制反转的原则。DI 框架和容器负责在应用程序中管理组件的依赖关系，根据组件的声明和配置，自动注入所需的依赖。通过使用 DI 和 IOC，可以实现松耦合、可测试和可维护的应用程序架构。</p>\n<h2 id=\"ioc-基本概念\" style=\"position:relative;\">IOC 基本概念<a href=\"#ioc-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\" aria-label=\"ioc 基本概念 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h2>\n<ol>\n<li>组件（Component）：组件是应用程序的构建块，可以是类、对象、服务或其他可被管理的实体。</li>\n<li>容器（Container）：容器是IOC框架的核心，负责创建和管理组件。它通过读取配置信息和应用程序代码，解析和创建组件的实例，并解决它们之间的依赖关系。</li>\n<li>注册（Registration）：注册是将组件与容器关联的过程。通常在配置文件或代码中指定组件的类型、名称、依赖关系等信息。</li>\n<li>解析（Resolution）：解析是指容器根据注册信息，创建并返回请求的组件实例的过程。解析可能涉及创建新的对象实例，或返回现有的单例对象。</li>\n<li>依赖注入（Dependency Injection）：依赖注入是IOC的重要特征，它是指容器自动将组件所依赖的其他组件注入到目标组件中的过程。依赖可以通过构造函数、属性或方法参数等方式注入。</li>\n<li>生命周期管理（Lifecycle Management）：IOC框架通常提供生命周期管理功能，用于创建、初始化、销毁组件。可以定义各种生命周期事件（如初始化、销毁），并由容器在适当的时间触发。</li>\n<li>作用域（Scope）：作用域定义了组件的生命周期范围。常见的作用域包括单例（Singleton）作用域，每次请求都返回同一个实例；原型（Prototype）作用域，每次请求都创建一个新的实例；会话（Session）作用域等。</li>\n<li>配置（Configuration）：IOC框架通常需要配置信息，如组件的注册信息、依赖关系、作用域设置等。配置可以通过XML、注解或其他方式提供。</li>\n<li>AOP（Aspect-Oriented Programming）：AOP是一种与IOC常一起使用的编程范式，用于实现横切关注点的分离。AOP允许在不改变组件代码的情况下，通过切面来实现跨组件的功能，如日志记录、事务管理等。</li>\n</ol>\n<h2 id=\"di-基本概念\" style=\"position:relative;\">DI 基本概念<a href=\"#di-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\" aria-label=\"di 基本概念 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h2>\n<p>在软件开发中，依赖注入（Dependency Injection，DI）是一种设计模式，用于管理组件之间的依赖关系。实现一个 DI 框架需要涉及以下几个概念：</p>\n<ol>\n<li>组件（Component）：组件是应用程序的构建块，可以是类、对象、服务或其他可被注入的实体。</li>\n<li>依赖（Dependency）：依赖是组件与其他组件之间的关系，表示一个组件需要使用或依赖其他组件的功能。</li>\n<li>注入器（Injector）：注入器是DI框架的核心，负责创建和管理组件的实例以及解决它们之间的依赖关系。</li>\n<li>注入点（Injection Point）：注入点是组件中用于接收依赖的地方，通常通过构造函数、属性或方法参数来定义。</li>\n<li>注入策略（Injection Strategy）：注入策略定义了如何将依赖注入到组件中。常见的注入策略包括构造函数注入、属性注入和方法注入。</li>\n<li>生命周期管理（Lifecycle Management）：DI框架可以提供组件的生命周期管理功能，包括创建、销毁和释放资源等操作。</li>\n<li>作用域（Scope）：作用域定义了组件的生命周期范围，例如单例作用域、原型作用域等。不同的作用域决定了组件的创建和销毁时机。</li>\n<li>配置（Configuration）：DI框架通常需要一些配置信息，如组件的依赖关系、作用域设置、注入策略等。</li>\n<li>AOP（Aspect-Oriented Programming）：AOP是一种编程范式，可用于在DI框架中实现横切关注点的分离，例如日志、事务管理等。</li>\n</ol>\n<h2 id=\"控制反转ioc其他实现方式\" style=\"position:relative;\">控制反转（IOC）其他实现方式<a href=\"#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\" aria-label=\"控制反转ioc其他实现方式 permalink\" class=\"custom-class after\"><svg t=\"1685947446267\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4780\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"25\" height=\"25\"><path d=\"M282.453333 676.693333m-181.333333 0a181.333333 181.333333 0 1 0 362.666667 0 181.333333 181.333333 0 1 0-362.666667 0Z\" fill=\"#FFCA5F\" p-id=\"4781\"></path><path d=\"M570.453333 111.36m-42.666666 0a42.666667 42.666667 0 1 0 85.333333 0 42.666667 42.666667 0 1 0-85.333333 0Z\" fill=\"#FFCA5F\" p-id=\"4782\"></path><path d=\"M388.053333 866.346667A208 208 0 0 1 241.066667 512l106.666666-106.666667 45.226667 45.226667-106.666667 106.666667A144 144 0 1 0 490.666667 760.32l107.733333-106.666667 45.226667 45.226667-107.733334 106.666667a207.146667 207.146667 0 0 1-147.84 60.8zM723.413333 617.173333l-45.226666-45.226666 100.906666-100.906667A144 144 0 1 0 576 267.52l-100.906667 100.906667-45.226666-45.44 100.906666-100.906667A208 208 0 0 1 824.32 516.266667z\" fill=\"#5C1CF7\" p-id=\"4783\"></path><path d=\"M442.794667 558.506667l134.570666-134.549334 45.248 45.269334-134.549333 134.549333z\" fill=\"#5C1CF7\" p-id=\"4784\"></path></svg></a></h2>\n<p>虽然依赖注入是实现IOC的一种常见方式，但并不是唯一的方式。不同的实现方式适用于不同的场景和需求，选择合适的实现方式取决于具体的应用程序架构和开发环境。</p>\n<ol>\n<li>服务定位器模式（Service Locator Pattern）：服务定位器模式是通过一个中心注册机制来获取所需要的服务。首先，所有的服务都在服务定位器中注册，然后当需要某个服务时，通过服务定位器来查找并获取。虽然这种方式可以实现IOC，但因为服务定位器往往隐藏了类之间的依赖关系，因此并不像DI那样推荐。</li>\n<li>工厂模式（Factory Pattern）：工厂模式是创建对象的一种最常见的方法，通过工厂类可以返回需要的实例，而不需要关心具体的实现。这样也可以实现IOC，即不直接在类中创建对象，而是通过工厂类来获取。不过工厂模式通常需要手动管理对象的生命周期，所以在某些情况下可能会比DI更复杂。</li>\n<li>模板方法模式（Template Method Pattern）：在模板方法模式中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种模式主要解决方法的执行顺序问题。</li>\n<li>策略模式（Strategy Pattern）：策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。在策略模式中，上下文（Context）不应知道正在使用哪个策略，策略和上下文都不应知道彼此的实现细节。</li>\n</ol>","fields":{"slug":"/post/2018/DI&IOC基本概念/"},"tableOfContents":"<ul>\n<li><a href=\"#di-%E5%92%8C-ioc-%E7%9A%84%E5%85%B3%E7%B3%BB\">DI 和 IOC 的关系</a></li>\n<li><a href=\"#ioc-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">IOC 基本概念</a></li>\n<li><a href=\"#di-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">DI 基本概念</a></li>\n<li><a href=\"#%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\">控制反转（IOC）其他实现方式</a></li>\n</ul>","frontmatter":{"title":"DI&IOC基本概念","date":"2018年05月01日","description":null,"tags":["IOC"]},"wordCount":{"words":242,"paragraphs":31,"sentences":31}}},"pageContext":{"slug":"/post/2018/DI&IOC基本概念/","previous":{"fields":{"slug":"/post/2018/基于canvas 实现 excel/"},"frontmatter":{"title":"基于canvas 实现 excel","tags":["文档","实时协作","富应用"],"description":null}},"next":{"fields":{"slug":"/post/2018/log/"},"frontmatter":{"title":"小程序实时日志","tags":["小程序","日志","实践"],"description":null}}}},"staticQueryHashes":["2887002447","3110208747","3255319198","63159454"],"slicesMap":{}}